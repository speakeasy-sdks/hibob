/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as errors from "../sdk/models/errors";
import * as operations from "../sdk/models/operations";
import * as shared from "../sdk/models/shared";
import { SDKConfiguration } from "./sdk";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse, RawAxiosRequestHeaders } from "axios";

export class TimeOff {
    private sdkConfiguration: SDKConfiguration;

    constructor(sdkConfig: SDKConfiguration) {
        this.sdkConfiguration = sdkConfig;
    }

    /**
     * Cancel an existing timeoff request
     *
     * @remarks
     * Cancels an existing time off request.<br /><b>Supported user types:</b> Employee, Service.
     */
    async deleteTimeoffEmployeesIdRequestsRequestId(
        req: operations.DeleteTimeoffEmployeesIdRequestsRequestIdRequest,
        security: operations.DeleteTimeoffEmployeesIdRequestsRequestIdSecurity,
        config?: AxiosRequestConfig
    ): Promise<operations.DeleteTimeoffEmployeesIdRequestsRequestIdResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.DeleteTimeoffEmployeesIdRequestsRequestIdRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const operationUrl: string = utils.generateURL(
            baseURL,
            "/timeoff/employees/{id}/requests/{requestId}",
            req
        );
        const client: AxiosInstance = this.sdkConfiguration.defaultClient;
        if (!(security instanceof utils.SpeakeasyBase)) {
            security = new operations.DeleteTimeoffEmployeesIdRequestsRequestIdSecurity(security);
        }
        const properties = utils.parseSecurityProperties(security);
        const headers: RawAxiosRequestHeaders = { ...config?.headers, ...properties.headers };
        headers["Accept"] = "*/*";

        headers["user-agent"] = this.sdkConfiguration.userAgent;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: operationUrl,
            method: "delete",
            headers: headers,
            responseType: "arraybuffer",
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.DeleteTimeoffEmployeesIdRequestsRequestIdResponse =
            new operations.DeleteTimeoffEmployeesIdRequestsRequestIdResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
        switch (true) {
            case httpRes?.status == 200:
                break;
        }

        return res;
    }

    /**
     * Get the balance for a given employee
     *
     * @remarks
     * Retrieve the balance for a given employee, for a given policy type, as of a given date.<br /><b>Supported user types:</b> Service
     */
    async getTimeoffEmployeesIdBalance(
        req: operations.GetTimeoffEmployeesIdBalanceRequest,
        security: operations.GetTimeoffEmployeesIdBalanceSecurity,
        config?: AxiosRequestConfig
    ): Promise<operations.GetTimeoffEmployeesIdBalanceResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.GetTimeoffEmployeesIdBalanceRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const operationUrl: string = utils.generateURL(
            baseURL,
            "/timeoff/employees/{id}/balance",
            req
        );
        const client: AxiosInstance = this.sdkConfiguration.defaultClient;
        if (!(security instanceof utils.SpeakeasyBase)) {
            security = new operations.GetTimeoffEmployeesIdBalanceSecurity(security);
        }
        const properties = utils.parseSecurityProperties(security);
        const headers: RawAxiosRequestHeaders = { ...config?.headers, ...properties.headers };
        const queryParams: string = utils.serializeQueryParams(req);
        headers["Accept"] = "application/json";

        headers["user-agent"] = this.sdkConfiguration.userAgent;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: operationUrl + queryParams,
            method: "get",
            headers: headers,
            responseType: "arraybuffer",
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.GetTimeoffEmployeesIdBalanceResponse =
            new operations.GetTimeoffEmployeesIdBalanceResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
        const decodedRes = new TextDecoder().decode(httpRes?.data);
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.balanceResult = utils.objectToClass(
                        JSON.parse(decodedRes),
                        shared.BalanceResult
                    );
                } else {
                    throw new errors.SDKError(
                        "unknown content-type received: " + contentType,
                        httpRes.status,
                        decodedRes,
                        httpRes
                    );
                }
                break;
            default:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.error = utils.objectToClass(JSON.parse(decodedRes), shared.ErrorT);
                } else {
                    throw new errors.SDKError(
                        "unknown content-type received: " + contentType,
                        httpRes.status,
                        decodedRes,
                        httpRes
                    );
                }
                break;
        }

        return res;
    }

    /**
     * Get the details of an existing timeoff request.
     *
     * @remarks
     * Supplies detailed info about an existing time off request.<br /><b>Supported user types:</b> Employee, Service.
     */
    async getTimeoffEmployeesIdRequestsRequestId(
        req: operations.GetTimeoffEmployeesIdRequestsRequestIdRequest,
        security: operations.GetTimeoffEmployeesIdRequestsRequestIdSecurity,
        config?: AxiosRequestConfig
    ): Promise<operations.GetTimeoffEmployeesIdRequestsRequestIdResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.GetTimeoffEmployeesIdRequestsRequestIdRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const operationUrl: string = utils.generateURL(
            baseURL,
            "/timeoff/employees/{id}/requests/{requestId}",
            req
        );
        const client: AxiosInstance = this.sdkConfiguration.defaultClient;
        if (!(security instanceof utils.SpeakeasyBase)) {
            security = new operations.GetTimeoffEmployeesIdRequestsRequestIdSecurity(security);
        }
        const properties = utils.parseSecurityProperties(security);
        const headers: RawAxiosRequestHeaders = { ...config?.headers, ...properties.headers };
        headers["Accept"] = "application/json";

        headers["user-agent"] = this.sdkConfiguration.userAgent;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: operationUrl,
            method: "get",
            headers: headers,
            responseType: "arraybuffer",
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.GetTimeoffEmployeesIdRequestsRequestIdResponse =
            new operations.GetTimeoffEmployeesIdRequestsRequestIdResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
        const decodedRes = new TextDecoder().decode(httpRes?.data);
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.timeoffRequest = utils.objectToClass(
                        JSON.parse(decodedRes),
                        shared.TimeoffRequest
                    );
                } else {
                    throw new errors.SDKError(
                        "unknown content-type received: " + contentType,
                        httpRes.status,
                        decodedRes,
                        httpRes
                    );
                }
                break;
            case httpRes?.status == 404:
                break;
        }

        return res;
    }

    /**
     * Read a list of who's out of the office today or on the specified date.
     *
     * @remarks
     * Returns the list of people that have a time off request today or on the specified date.<br /><b>Supported user types:</b> Employee, Service.
     */
    async getTimeoffOuttoday(
        req: operations.GetTimeoffOuttodayRequest,
        security: operations.GetTimeoffOuttodaySecurity,
        config?: AxiosRequestConfig
    ): Promise<operations.GetTimeoffOuttodayResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.GetTimeoffOuttodayRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const operationUrl: string = baseURL.replace(/\/$/, "") + "/timeoff/outtoday";
        const client: AxiosInstance = this.sdkConfiguration.defaultClient;
        if (!(security instanceof utils.SpeakeasyBase)) {
            security = new operations.GetTimeoffOuttodaySecurity(security);
        }
        const properties = utils.parseSecurityProperties(security);
        const headers: RawAxiosRequestHeaders = { ...config?.headers, ...properties.headers };
        const queryParams: string = utils.serializeQueryParams(req);
        headers["Accept"] = "application/json";

        headers["user-agent"] = this.sdkConfiguration.userAgent;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: operationUrl + queryParams,
            method: "get",
            headers: headers,
            responseType: "arraybuffer",
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.GetTimeoffOuttodayResponse =
            new operations.GetTimeoffOuttodayResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
        const decodedRes = new TextDecoder().decode(httpRes?.data);
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.outTodays = utils.objectToClass(JSON.parse(decodedRes), shared.OutTodays);
                } else {
                    throw new errors.SDKError(
                        "unknown content-type received: " + contentType,
                        httpRes.status,
                        decodedRes,
                        httpRes
                    );
                }
                break;
            default:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.error = utils.objectToClass(JSON.parse(decodedRes), shared.ErrorT);
                } else {
                    throw new errors.SDKError(
                        "unknown content-type received: " + contentType,
                        httpRes.status,
                        decodedRes,
                        httpRes
                    );
                }
                break;
        }

        return res;
    }

    /**
     * Get Policy details.
     *
     * @remarks
     * Get details about a given policy.<br /><b>Supported user types:</b> Service.
     */
    async getTimeoffPolicies(
        req: operations.GetTimeoffPoliciesRequest,
        security: operations.GetTimeoffPoliciesSecurity,
        config?: AxiosRequestConfig
    ): Promise<operations.GetTimeoffPoliciesResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.GetTimeoffPoliciesRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const operationUrl: string = baseURL.replace(/\/$/, "") + "/timeoff/policies";
        const client: AxiosInstance = this.sdkConfiguration.defaultClient;
        if (!(security instanceof utils.SpeakeasyBase)) {
            security = new operations.GetTimeoffPoliciesSecurity(security);
        }
        const properties = utils.parseSecurityProperties(security);
        const headers: RawAxiosRequestHeaders = { ...config?.headers, ...properties.headers };
        const queryParams: string = utils.serializeQueryParams(req);
        headers["Accept"] = "application/json";

        headers["user-agent"] = this.sdkConfiguration.userAgent;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: operationUrl + queryParams,
            method: "get",
            headers: headers,
            responseType: "arraybuffer",
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.GetTimeoffPoliciesResponse =
            new operations.GetTimeoffPoliciesResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
        const decodedRes = new TextDecoder().decode(httpRes?.data);
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.policy = utils.objectToClass(JSON.parse(decodedRes), shared.Policy);
                } else {
                    throw new errors.SDKError(
                        "unknown content-type received: " + contentType,
                        httpRes.status,
                        decodedRes,
                        httpRes
                    );
                }
                break;
            case httpRes?.status == 404:
                break;
        }

        return res;
    }

    /**
     * Get a list of policy names for a given policy type.
     *
     * @remarks
     * Get a list of policy names for the user's defined policy type.<br /><b>Supported user types:</b> Service.
     */
    async getTimeoffPoliciesNames(
        req: operations.GetTimeoffPoliciesNamesRequest,
        security: operations.GetTimeoffPoliciesNamesSecurity,
        config?: AxiosRequestConfig
    ): Promise<operations.GetTimeoffPoliciesNamesResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.GetTimeoffPoliciesNamesRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const operationUrl: string = baseURL.replace(/\/$/, "") + "/timeoff/policies/names";
        const client: AxiosInstance = this.sdkConfiguration.defaultClient;
        if (!(security instanceof utils.SpeakeasyBase)) {
            security = new operations.GetTimeoffPoliciesNamesSecurity(security);
        }
        const properties = utils.parseSecurityProperties(security);
        const headers: RawAxiosRequestHeaders = { ...config?.headers, ...properties.headers };
        const queryParams: string = utils.serializeQueryParams(req);
        headers["Accept"] = "application/json";

        headers["user-agent"] = this.sdkConfiguration.userAgent;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: operationUrl + queryParams,
            method: "get",
            headers: headers,
            responseType: "arraybuffer",
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.GetTimeoffPoliciesNamesResponse =
            new operations.GetTimeoffPoliciesNamesResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
        const decodedRes = new TextDecoder().decode(httpRes?.data);
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.policyNames = utils.objectToClass(
                        JSON.parse(decodedRes),
                        shared.PolicyNames
                    );
                } else {
                    throw new errors.SDKError(
                        "unknown content-type received: " + contentType,
                        httpRes.status,
                        decodedRes,
                        httpRes
                    );
                }
                break;
        }

        return res;
    }

    /**
     * Get all policy types names.
     *
     * @remarks
     * Get a list of all policy type names.<br /><b>Supported user types:</b> Service.
     */
    async getTimeoffPolicyTypes(
        security: operations.GetTimeoffPolicyTypesSecurity,
        config?: AxiosRequestConfig
    ): Promise<operations.GetTimeoffPolicyTypesResponse> {
        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const operationUrl: string = baseURL.replace(/\/$/, "") + "/timeoff/policy-types";
        const client: AxiosInstance = this.sdkConfiguration.defaultClient;
        if (!(security instanceof utils.SpeakeasyBase)) {
            security = new operations.GetTimeoffPolicyTypesSecurity(security);
        }
        const properties = utils.parseSecurityProperties(security);
        const headers: RawAxiosRequestHeaders = { ...config?.headers, ...properties.headers };
        headers["Accept"] = "application/json";

        headers["user-agent"] = this.sdkConfiguration.userAgent;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: operationUrl,
            method: "get",
            headers: headers,
            responseType: "arraybuffer",
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.GetTimeoffPolicyTypesResponse =
            new operations.GetTimeoffPolicyTypesResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
        const decodedRes = new TextDecoder().decode(httpRes?.data);
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.policyTypes = utils.objectToClass(
                        JSON.parse(decodedRes),
                        shared.PolicyTypes
                    );
                } else {
                    throw new errors.SDKError(
                        "unknown content-type received: " + contentType,
                        httpRes.status,
                        decodedRes,
                        httpRes
                    );
                }
                break;
            default:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.error = utils.objectToClass(JSON.parse(decodedRes), shared.ErrorT);
                } else {
                    throw new errors.SDKError(
                        "unknown content-type received: " + contentType,
                        httpRes.status,
                        decodedRes,
                        httpRes
                    );
                }
                break;
        }

        return res;
    }

    /**
     * Get Policy type details
     *
     * @remarks
     * Get details about a given policy type.<br /><b>Supported user types:</b> Service.
     */
    async getTimeoffPolicyTypesPolicyType(
        req: operations.GetTimeoffPolicyTypesPolicyTypeRequest,
        security: operations.GetTimeoffPolicyTypesPolicyTypeSecurity,
        config?: AxiosRequestConfig
    ): Promise<operations.GetTimeoffPolicyTypesPolicyTypeResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.GetTimeoffPolicyTypesPolicyTypeRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const operationUrl: string = utils.generateURL(
            baseURL,
            "/timeoff/policy-types/{policyType}",
            req
        );
        const client: AxiosInstance = this.sdkConfiguration.defaultClient;
        if (!(security instanceof utils.SpeakeasyBase)) {
            security = new operations.GetTimeoffPolicyTypesPolicyTypeSecurity(security);
        }
        const properties = utils.parseSecurityProperties(security);
        const headers: RawAxiosRequestHeaders = { ...config?.headers, ...properties.headers };
        headers["Accept"] = "application/json";

        headers["user-agent"] = this.sdkConfiguration.userAgent;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: operationUrl,
            method: "get",
            headers: headers,
            responseType: "arraybuffer",
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.GetTimeoffPolicyTypesPolicyTypeResponse =
            new operations.GetTimeoffPolicyTypesPolicyTypeResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
        const decodedRes = new TextDecoder().decode(httpRes?.data);
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.policyType = utils.objectToClass(JSON.parse(decodedRes), shared.PolicyType);
                } else {
                    throw new errors.SDKError(
                        "unknown content-type received: " + contentType,
                        httpRes.status,
                        decodedRes,
                        httpRes
                    );
                }
                break;
            case httpRes?.status == 404:
                break;
        }

        return res;
    }

    /**
     * Get Policy type reason codes
     *
     * @remarks
     * Get list of reason codes for a given policy type.<br /><b>Supported user types:</b> Service.
     */
    async getTimeoffPolicyTypesPolicyTypeReasonCodes(
        req: operations.GetTimeoffPolicyTypesPolicyTypeReasonCodesRequest,
        security: operations.GetTimeoffPolicyTypesPolicyTypeReasonCodesSecurity,
        config?: AxiosRequestConfig
    ): Promise<operations.GetTimeoffPolicyTypesPolicyTypeReasonCodesResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.GetTimeoffPolicyTypesPolicyTypeReasonCodesRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const operationUrl: string = utils.generateURL(
            baseURL,
            "/timeoff/policy-types/{policyType}/reason-codes",
            req
        );
        const client: AxiosInstance = this.sdkConfiguration.defaultClient;
        if (!(security instanceof utils.SpeakeasyBase)) {
            security = new operations.GetTimeoffPolicyTypesPolicyTypeReasonCodesSecurity(security);
        }
        const properties = utils.parseSecurityProperties(security);
        const headers: RawAxiosRequestHeaders = { ...config?.headers, ...properties.headers };
        headers["Accept"] = "application/json";

        headers["user-agent"] = this.sdkConfiguration.userAgent;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: operationUrl,
            method: "get",
            headers: headers,
            responseType: "arraybuffer",
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.GetTimeoffPolicyTypesPolicyTypeReasonCodesResponse =
            new operations.GetTimeoffPolicyTypesPolicyTypeReasonCodesResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
        const decodedRes = new TextDecoder().decode(httpRes?.data);
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.reasonCodes = utils.objectToClass(
                        JSON.parse(decodedRes),
                        shared.ReasonCodes
                    );
                } else {
                    throw new errors.SDKError(
                        "unknown content-type received: " + contentType,
                        httpRes.status,
                        decodedRes,
                        httpRes
                    );
                }
                break;
            case httpRes?.status == 404:
                break;
        }

        return res;
    }

    /**
     * Get all new/deleted time off requests since the specified date.
     *
     * @remarks
     * Returns the list of time off requests approved or canceled since the specified date.<br /><b>Supported user types:</b> Employee, Service.
     */
    async getTimeoffRequestsChanges(
        req: operations.GetTimeoffRequestsChangesRequest,
        security: operations.GetTimeoffRequestsChangesSecurity,
        config?: AxiosRequestConfig
    ): Promise<operations.GetTimeoffRequestsChangesResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.GetTimeoffRequestsChangesRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const operationUrl: string = baseURL.replace(/\/$/, "") + "/timeoff/requests/changes";
        const client: AxiosInstance = this.sdkConfiguration.defaultClient;
        if (!(security instanceof utils.SpeakeasyBase)) {
            security = new operations.GetTimeoffRequestsChangesSecurity(security);
        }
        const properties = utils.parseSecurityProperties(security);
        const headers: RawAxiosRequestHeaders = { ...config?.headers, ...properties.headers };
        const queryParams: string = utils.serializeQueryParams(req);
        headers["Accept"] = "application/json";

        headers["user-agent"] = this.sdkConfiguration.userAgent;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: operationUrl + queryParams,
            method: "get",
            headers: headers,
            responseType: "arraybuffer",
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.GetTimeoffRequestsChangesResponse =
            new operations.GetTimeoffRequestsChangesResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
        const decodedRes = new TextDecoder().decode(httpRes?.data);
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.timeoffChanges = utils.objectToClass(
                        JSON.parse(decodedRes),
                        shared.TimeoffChanges
                    );
                } else {
                    throw new errors.SDKError(
                        "unknown content-type received: " + contentType,
                        httpRes.status,
                        decodedRes,
                        httpRes
                    );
                }
                break;
        }

        return res;
    }

    /**
     * Read a list of who's out of the office.
     *
     * @remarks
     * Returns time off information for a given date range.<br /><b>Supported user types:</b> Employee, Service.
     */
    async getTimeoffWhosout(
        req: operations.GetTimeoffWhosoutRequest,
        security: operations.GetTimeoffWhosoutSecurity,
        config?: AxiosRequestConfig
    ): Promise<operations.GetTimeoffWhosoutResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.GetTimeoffWhosoutRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const operationUrl: string = baseURL.replace(/\/$/, "") + "/timeoff/whosout";
        const client: AxiosInstance = this.sdkConfiguration.defaultClient;
        if (!(security instanceof utils.SpeakeasyBase)) {
            security = new operations.GetTimeoffWhosoutSecurity(security);
        }
        const properties = utils.parseSecurityProperties(security);
        const headers: RawAxiosRequestHeaders = { ...config?.headers, ...properties.headers };
        const queryParams: string = utils.serializeQueryParams(req);
        headers["Accept"] = "application/json";

        headers["user-agent"] = this.sdkConfiguration.userAgent;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: operationUrl + queryParams,
            method: "get",
            headers: headers,
            responseType: "arraybuffer",
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.GetTimeoffWhosoutResponse = new operations.GetTimeoffWhosoutResponse({
            statusCode: httpRes.status,
            contentType: contentType,
            rawResponse: httpRes,
        });
        const decodedRes = new TextDecoder().decode(httpRes?.data);
        switch (true) {
            case httpRes?.status == 200:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.requests = utils.objectToClass(JSON.parse(decodedRes), shared.Requests);
                } else {
                    throw new errors.SDKError(
                        "unknown content-type received: " + contentType,
                        httpRes.status,
                        decodedRes,
                        httpRes
                    );
                }
                break;
            default:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.error = utils.objectToClass(JSON.parse(decodedRes), shared.ErrorT);
                } else {
                    throw new errors.SDKError(
                        "unknown content-type received: " + contentType,
                        httpRes.status,
                        decodedRes,
                        httpRes
                    );
                }
                break;
        }

        return res;
    }

    /**
     * Create a balance adjustment.
     *
     * @remarks
     * Create a balance adjustment for a given employee for a given effective date.<br /><b>Supported user types:</b> Service
     */
    async postTimeoffEmployeesIdAdjustments(
        req: operations.PostTimeoffEmployeesIdAdjustmentsRequest,
        security: operations.PostTimeoffEmployeesIdAdjustmentsSecurity,
        config?: AxiosRequestConfig
    ): Promise<operations.PostTimeoffEmployeesIdAdjustmentsResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.PostTimeoffEmployeesIdAdjustmentsRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const operationUrl: string = utils.generateURL(
            baseURL,
            "/timeoff/employees/{id}/adjustments",
            req
        );

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, null];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
                req,
                "adjustmentRequest",
                "json"
            );
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }
        const client: AxiosInstance = this.sdkConfiguration.defaultClient;
        if (!(security instanceof utils.SpeakeasyBase)) {
            security = new operations.PostTimeoffEmployeesIdAdjustmentsSecurity(security);
        }
        const properties = utils.parseSecurityProperties(security);
        const headers: RawAxiosRequestHeaders = {
            ...reqBodyHeaders,
            ...config?.headers,
            ...properties.headers,
        };
        if (reqBody == null) throw new Error("request body is required");
        headers["Accept"] = "application/json";

        headers["user-agent"] = this.sdkConfiguration.userAgent;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: operationUrl,
            method: "post",
            headers: headers,
            responseType: "arraybuffer",
            data: reqBody,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.PostTimeoffEmployeesIdAdjustmentsResponse =
            new operations.PostTimeoffEmployeesIdAdjustmentsResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
        const decodedRes = new TextDecoder().decode(httpRes?.data);
        switch (true) {
            case httpRes?.status == 200:
                break;
            default:
                if (utils.matchContentType(contentType, `application/json`)) {
                    res.error = utils.objectToClass(JSON.parse(decodedRes), shared.ErrorT);
                } else {
                    throw new errors.SDKError(
                        "unknown content-type received: " + contentType,
                        httpRes.status,
                        decodedRes,
                        httpRes
                    );
                }
                break;
        }

        return res;
    }

    /**
     * Submit a new time off request.
     *
     * @remarks
     * Submits a new timeoff request.<br /><b>Supported user types:</b> Employee, Service.
     */
    async postTimeoffEmployeesIdRequests(
        req: operations.PostTimeoffEmployeesIdRequestsRequest,
        security: operations.PostTimeoffEmployeesIdRequestsSecurity,
        config?: AxiosRequestConfig
    ): Promise<operations.PostTimeoffEmployeesIdRequestsResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.PostTimeoffEmployeesIdRequestsRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const operationUrl: string = utils.generateURL(
            baseURL,
            "/timeoff/employees/{id}/requests",
            req
        );

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, null];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
                req,
                "submitTimeoffRequest",
                "json"
            );
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }
        const client: AxiosInstance = this.sdkConfiguration.defaultClient;
        if (!(security instanceof utils.SpeakeasyBase)) {
            security = new operations.PostTimeoffEmployeesIdRequestsSecurity(security);
        }
        const properties = utils.parseSecurityProperties(security);
        const headers: RawAxiosRequestHeaders = {
            ...reqBodyHeaders,
            ...config?.headers,
            ...properties.headers,
        };
        if (reqBody == null) throw new Error("request body is required");
        headers["Accept"] = "*/*";

        headers["user-agent"] = this.sdkConfiguration.userAgent;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: operationUrl,
            method: "post",
            headers: headers,
            responseType: "arraybuffer",
            data: reqBody,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.PostTimeoffEmployeesIdRequestsResponse =
            new operations.PostTimeoffEmployeesIdRequestsResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
        switch (true) {
            case httpRes?.status == 200:
                break;
        }

        return res;
    }

    /**
     * Add a list of reason codes for a given policy type.
     *
     * @remarks
     * Add a list of reason codes for a given policy type.<br /><b>Supported user types:</b> Service.
     */
    async postTimeoffPolicyTypesPolicyTypeReasonCodes(
        req: operations.PostTimeoffPolicyTypesPolicyTypeReasonCodesRequest,
        security: operations.PostTimeoffPolicyTypesPolicyTypeReasonCodesSecurity,
        config?: AxiosRequestConfig
    ): Promise<operations.PostTimeoffPolicyTypesPolicyTypeReasonCodesResponse> {
        if (!(req instanceof utils.SpeakeasyBase)) {
            req = new operations.PostTimeoffPolicyTypesPolicyTypeReasonCodesRequest(req);
        }

        const baseURL: string = utils.templateUrl(
            this.sdkConfiguration.serverURL,
            this.sdkConfiguration.serverDefaults
        );
        const operationUrl: string = utils.generateURL(
            baseURL,
            "/timeoff/policy-types/{policyType}/reason-codes",
            req
        );

        let [reqBodyHeaders, reqBody]: [object, any] = [{}, null];

        try {
            [reqBodyHeaders, reqBody] = utils.serializeRequestBody(req, "reasonCodesNames", "json");
        } catch (e: unknown) {
            if (e instanceof Error) {
                throw new Error(`Error serializing request body, cause: ${e.message}`);
            }
        }
        const client: AxiosInstance = this.sdkConfiguration.defaultClient;
        if (!(security instanceof utils.SpeakeasyBase)) {
            security = new operations.PostTimeoffPolicyTypesPolicyTypeReasonCodesSecurity(security);
        }
        const properties = utils.parseSecurityProperties(security);
        const headers: RawAxiosRequestHeaders = {
            ...reqBodyHeaders,
            ...config?.headers,
            ...properties.headers,
        };
        if (reqBody == null) throw new Error("request body is required");
        headers["Accept"] = "*/*";

        headers["user-agent"] = this.sdkConfiguration.userAgent;

        const httpRes: AxiosResponse = await client.request({
            validateStatus: () => true,
            url: operationUrl,
            method: "post",
            headers: headers,
            responseType: "arraybuffer",
            data: reqBody,
            ...config,
        });

        const contentType: string = httpRes?.headers?.["content-type"] ?? "";

        if (httpRes?.status == null) {
            throw new Error(`status code not found in response: ${httpRes}`);
        }

        const res: operations.PostTimeoffPolicyTypesPolicyTypeReasonCodesResponse =
            new operations.PostTimeoffPolicyTypesPolicyTypeReasonCodesResponse({
                statusCode: httpRes.status,
                contentType: contentType,
                rawResponse: httpRes,
            });
        switch (true) {
            case [200, 404].includes(httpRes?.status):
                break;
        }

        return res;
    }
}
