/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SDKHooks } from "../hooks";
import { SDK_METADATA, SDKOptions, serverURLFromOptions } from "../lib/config";
import * as enc$ from "../lib/encodings";
import { HTTPClient } from "../lib/http";
import * as schemas$ from "../lib/schemas";
import { ClientSDK, RequestOptions } from "../lib/sdks";
import { SecurityInput } from "../lib/security";
import * as errors from "./models/errors";
import * as operations from "./models/operations";

export class TimeOff extends ClientSDK {
    private readonly options$: SDKOptions & { hooks?: SDKHooks };

    constructor(options: SDKOptions = {}) {
        const opt = options as unknown;
        let hooks: SDKHooks;
        if (
            typeof opt === "object" &&
            opt != null &&
            "hooks" in opt &&
            opt.hooks instanceof SDKHooks
        ) {
            hooks = opt.hooks;
        } else {
            hooks = new SDKHooks();
        }

        super({
            client: options.httpClient || new HTTPClient(),
            baseURL: serverURLFromOptions(options),
            hooks,
        });

        this.options$ = { ...options, hooks };
        void this.options$;
    }

    /**
     * Cancel an existing timeoff request
     *
     * @remarks
     * Cancels an existing time off request.<br />
     */
    async deleteTimeoffEmployeesIdRequestsRequestId(
        input: operations.DeleteTimeoffEmployeesIdRequestsRequestIdRequest,
        options?: RequestOptions
    ): Promise<operations.DeleteTimeoffEmployeesIdRequestsRequestIdResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = schemas$.parse(
            input,
            (value$) =>
                operations.DeleteTimeoffEmployeesIdRequestsRequestIdRequest$.outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            id: enc$.encodeSimple("id", payload$.id, { explode: false, charEncoding: "percent" }),
            requestId: enc$.encodeSimple("requestId", payload$.requestId, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/timeoff/employees/{id}/requests/{requestId}")(
            pathParams$
        );

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "delete_/timeoff/employees/{id}/requests/{requestId}",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: [] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "DELETE",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchStatusCode(response, 200)) {
            // fallthrough
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return schemas$.parse(
            undefined,
            () =>
                operations.DeleteTimeoffEmployeesIdRequestsRequestIdResponse$.inboundSchema.parse(
                    responseFields$
                ),
            "Response validation failed"
        );
    }

    /**
     * Get the balance for a given employee
     *
     * @remarks
     * Retrieve the balance for a given employee, for a given policy type, as of a given date.<br />
     */
    async getTimeoffEmployeesIdBalance(
        input: operations.GetTimeoffEmployeesIdBalanceRequest,
        options?: RequestOptions
    ): Promise<operations.GetTimeoffEmployeesIdBalanceResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) =>
                operations.GetTimeoffEmployeesIdBalanceRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            id: enc$.encodeSimple("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };
        const path$ = this.templateURLComponent("/timeoff/employees/{id}/balance")(pathParams$);

        const query$ = [
            enc$.encodeForm("date", payload$.date, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("policyType", payload$.policyType, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "get_/timeoff/employees/{id}/balance",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: [] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.GetTimeoffEmployeesIdBalanceResponse$.inboundSchema.parse({
                        ...responseFields$,
                        BalanceResult: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else if (this.matchResponse(response, "default", "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.GetTimeoffEmployeesIdBalanceResponse$.inboundSchema.parse({
                        ...responseFields$,
                        Error: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Get the details of an existing timeoff request.
     *
     * @remarks
     * Supplies detailed info about an existing time off request.<br />
     */
    async getTimeoffEmployeesIdRequestsRequestId(
        input: operations.GetTimeoffEmployeesIdRequestsRequestIdRequest,
        options?: RequestOptions
    ): Promise<operations.GetTimeoffEmployeesIdRequestsRequestIdResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) =>
                operations.GetTimeoffEmployeesIdRequestsRequestIdRequest$.outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            id: enc$.encodeSimple("id", payload$.id, { explode: false, charEncoding: "percent" }),
            requestId: enc$.encodeSimple("requestId", payload$.requestId, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/timeoff/employees/{id}/requests/{requestId}")(
            pathParams$
        );

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "get_/timeoff/employees/{id}/requests/{requestId}",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: [] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.GetTimeoffEmployeesIdRequestsRequestIdResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            TimeoffRequest: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else if (this.matchStatusCode(response, 404)) {
            // fallthrough
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return schemas$.parse(
            undefined,
            () =>
                operations.GetTimeoffEmployeesIdRequestsRequestIdResponse$.inboundSchema.parse(
                    responseFields$
                ),
            "Response validation failed"
        );
    }

    /**
     * Read a list of who's out of the office today or on the specified date.
     *
     * @remarks
     * Returns the list of people that have a time off request today or on the specified date.<br />
     */
    async getTimeoffOuttoday(
        input: operations.GetTimeoffOuttodayRequest,
        options?: RequestOptions
    ): Promise<operations.GetTimeoffOuttodayResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => operations.GetTimeoffOuttodayRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/timeoff/outtoday")();

        const query$ = [
            enc$.encodeForm("includeHourly", payload$.includeHourly, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("includePrivate", payload$.includePrivate, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("siteId", payload$.siteId, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("today", payload$.today, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "get_/timeoff/outtoday",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: [] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.GetTimeoffOuttodayResponse$.inboundSchema.parse({
                        ...responseFields$,
                        OutTodays: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else if (this.matchResponse(response, "default", "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.GetTimeoffOuttodayResponse$.inboundSchema.parse({
                        ...responseFields$,
                        Error: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Get Policy details.
     *
     * @remarks
     * Get details about a given policy.<br />
     */
    async getTimeoffPolicies(
        input: operations.GetTimeoffPoliciesRequest,
        options?: RequestOptions
    ): Promise<operations.GetTimeoffPoliciesResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => operations.GetTimeoffPoliciesRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/timeoff/policies")();

        const query$ = [
            enc$.encodeForm("policyName", payload$.policyName, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "get_/timeoff/policies",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: [] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.GetTimeoffPoliciesResponse$.inboundSchema.parse({
                        ...responseFields$,
                        Policy: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else if (this.matchStatusCode(response, 404)) {
            // fallthrough
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return schemas$.parse(
            undefined,
            () => operations.GetTimeoffPoliciesResponse$.inboundSchema.parse(responseFields$),
            "Response validation failed"
        );
    }

    /**
     * Get a list of policy names for a given policy type.
     *
     * @remarks
     * Get a list of policy names for the user's defined policy type.<br />
     */
    async getTimeoffPoliciesNames(
        input: operations.GetTimeoffPoliciesNamesRequest,
        options?: RequestOptions
    ): Promise<operations.GetTimeoffPoliciesNamesResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => operations.GetTimeoffPoliciesNamesRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/timeoff/policies/names")();

        const query$ = [
            enc$.encodeForm("policyTypeName", payload$.policyTypeName, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "get_/timeoff/policies/names",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: [] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.GetTimeoffPoliciesNamesResponse$.inboundSchema.parse({
                        ...responseFields$,
                        PolicyNames: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Get all policy types names.
     *
     * @remarks
     * Get a list of all policy type names.<br />
     */
    async getTimeoffPolicyTypes(
        options?: RequestOptions
    ): Promise<operations.GetTimeoffPolicyTypesResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const path$ = this.templateURLComponent("/timeoff/policy-types")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "get_/timeoff/policy-types",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: [] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.GetTimeoffPolicyTypesResponse$.inboundSchema.parse({
                        ...responseFields$,
                        PolicyTypes: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else if (this.matchResponse(response, "default", "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.GetTimeoffPolicyTypesResponse$.inboundSchema.parse({
                        ...responseFields$,
                        Error: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Get Policy type details
     *
     * @remarks
     * Get details about a given policy type.<br />
     */
    async getTimeoffPolicyTypesPolicyType(
        input: operations.GetTimeoffPolicyTypesPolicyTypeRequest,
        options?: RequestOptions
    ): Promise<operations.GetTimeoffPolicyTypesPolicyTypeResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) =>
                operations.GetTimeoffPolicyTypesPolicyTypeRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            policyType: enc$.encodeSimple("policyType", payload$.policyType, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/timeoff/policy-types/{policyType}")(pathParams$);

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "get_/timeoff/policy-types/{policyType}",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: [] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.GetTimeoffPolicyTypesPolicyTypeResponse$.inboundSchema.parse({
                        ...responseFields$,
                        PolicyType: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else if (this.matchStatusCode(response, 404)) {
            // fallthrough
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return schemas$.parse(
            undefined,
            () =>
                operations.GetTimeoffPolicyTypesPolicyTypeResponse$.inboundSchema.parse(
                    responseFields$
                ),
            "Response validation failed"
        );
    }

    /**
     * Get Policy type reason codes
     *
     * @remarks
     * Get list of reason codes for a given policy type.<br />
     */
    async getTimeoffPolicyTypesPolicyTypeReasonCodes(
        input: operations.GetTimeoffPolicyTypesPolicyTypeReasonCodesRequest,
        options?: RequestOptions
    ): Promise<operations.GetTimeoffPolicyTypesPolicyTypeReasonCodesResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) =>
                operations.GetTimeoffPolicyTypesPolicyTypeReasonCodesRequest$.outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            policyType: enc$.encodeSimple("policyType", payload$.policyType, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/timeoff/policy-types/{policyType}/reason-codes")(
            pathParams$
        );

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "get_/timeoff/policy-types/{policyType}/reason-codes",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: [] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.GetTimeoffPolicyTypesPolicyTypeReasonCodesResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            ReasonCodes: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else if (this.matchStatusCode(response, 404)) {
            // fallthrough
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return schemas$.parse(
            undefined,
            () =>
                operations.GetTimeoffPolicyTypesPolicyTypeReasonCodesResponse$.inboundSchema.parse(
                    responseFields$
                ),
            "Response validation failed"
        );
    }

    /**
     * Get all new/deleted time off requests since the specified date.
     *
     * @remarks
     * Returns the list of time off requests that are pending, approved or canceled since the specified date.<br />
     */
    async getTimeoffRequestsChanges(
        input: operations.GetTimeoffRequestsChangesRequest,
        options?: RequestOptions
    ): Promise<operations.GetTimeoffRequestsChangesResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => operations.GetTimeoffRequestsChangesRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/timeoff/requests/changes")();

        const query$ = [
            enc$.encodeForm("includePending", payload$.includePending, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("since", payload$.since, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "get_/timeoff/requests/changes",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: [] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.GetTimeoffRequestsChangesResponse$.inboundSchema.parse({
                        ...responseFields$,
                        TimeoffChanges: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Read a list of who's out of the office.
     *
     * @remarks
     * Returns time off information for a given date range.<br /><b>Supported user types:</b> Service.
     */
    async getTimeoffWhosout(
        input: operations.GetTimeoffWhosoutRequest,
        options?: RequestOptions
    ): Promise<operations.GetTimeoffWhosoutResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => operations.GetTimeoffWhosoutRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/timeoff/whosout")();

        const query$ = [
            enc$.encodeForm("from", payload$.from, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("includeHourly", payload$.includeHourly, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("includePending", payload$.includePending, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("includePrivate", payload$.includePrivate, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("to", payload$.to, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "get_/timeoff/whosout",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: [] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.GetTimeoffWhosoutResponse$.inboundSchema.parse({
                        ...responseFields$,
                        Requests: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else if (this.matchResponse(response, "default", "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.GetTimeoffWhosoutResponse$.inboundSchema.parse({
                        ...responseFields$,
                        Error: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * Create a balance adjustment.
     *
     * @remarks
     * Create a balance adjustment for a given employee for a given effective date.<br />
     */
    async postTimeoffEmployeesIdAdjustments(
        input: operations.PostTimeoffEmployeesIdAdjustmentsRequest,
        options?: RequestOptions
    ): Promise<operations.PostTimeoffEmployeesIdAdjustmentsResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) =>
                operations.PostTimeoffEmployeesIdAdjustmentsRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$.AdjustmentRequest, { explode: true });

        const pathParams$ = {
            id: enc$.encodeSimple("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };
        const path$ = this.templateURLComponent("/timeoff/employees/{id}/adjustments")(pathParams$);

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "post_/timeoff/employees/{id}/adjustments",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: [] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchStatusCode(response, 200)) {
            // fallthrough
        } else if (this.matchResponse(response, "default", "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.PostTimeoffEmployeesIdAdjustmentsResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            Error: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return schemas$.parse(
            undefined,
            () =>
                operations.PostTimeoffEmployeesIdAdjustmentsResponse$.inboundSchema.parse(
                    responseFields$
                ),
            "Response validation failed"
        );
    }

    /**
     * Submit a new time off request of different hours per day.
     *
     * @remarks
     * Submits a new timeoff request of different hours per day.<br /><b>Supported user types:</b> Employee, Service.
     */
    async postTimeoffEmployeesIdDiffHoursRequests(
        input: operations.PostTimeoffEmployeesIdDiffHoursRequestsRequest,
        security: operations.PostTimeoffEmployeesIdDiffHoursRequestsSecurity,
        options?: RequestOptions
    ): Promise<operations.PostTimeoffEmployeesIdDiffHoursRequestsResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "*/*");

        const payload$ = schemas$.parse(
            input,
            (value$) =>
                operations.PostTimeoffEmployeesIdDiffHoursRequestsRequest$.outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$.SubmitTimeoffRequestDiffHours, {
            explode: true,
        });

        const pathParams$ = {
            id: enc$.encodeSimple("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };
        const path$ = this.templateURLComponent("/timeoff/employees/{id}/diffHours/requests")(
            pathParams$
        );

        const query$ = "";

        const security$: SecurityInput[][] = [
            [
                {
                    type: "http:basic",
                    value: {
                        username: security?.basic?.username,
                        password: security?.basic?.password,
                    },
                },
            ],
            [
                {
                    fieldName: "Authorization",
                    type: "apiKey:header",
                    value: security?.bearer,
                },
            ],
        ];
        const securitySettings$ = this.resolveSecurity(...security$);
        const context = {
            operationID: "post_/timeoff/employees/{id}/diffHours/requests",
            oAuth2Scopes: [],
            securitySource: security$,
        };

        const doOptions = { context, errorCodes: [] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchStatusCode(response, 200)) {
            // fallthrough
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return schemas$.parse(
            undefined,
            () =>
                operations.PostTimeoffEmployeesIdDiffHoursRequestsResponse$.inboundSchema.parse(
                    responseFields$
                ),
            "Response validation failed"
        );
    }

    /**
     * Submit a new time off request.
     *
     * @remarks
     * Submits a new timeoff request.<br />
     */
    async postTimeoffEmployeesIdRequests(
        input: operations.PostTimeoffEmployeesIdRequestsRequest,
        options?: RequestOptions
    ): Promise<operations.PostTimeoffEmployeesIdRequestsResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "*/*");

        const payload$ = schemas$.parse(
            input,
            (value$) =>
                operations.PostTimeoffEmployeesIdRequestsRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$.SubmitTimeoffRequest, { explode: true });

        const pathParams$ = {
            id: enc$.encodeSimple("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };
        const path$ = this.templateURLComponent("/timeoff/employees/{id}/requests")(pathParams$);

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "post_/timeoff/employees/{id}/requests",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: [] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchStatusCode(response, 200)) {
            // fallthrough
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return schemas$.parse(
            undefined,
            () =>
                operations.PostTimeoffEmployeesIdRequestsResponse$.inboundSchema.parse(
                    responseFields$
                ),
            "Response validation failed"
        );
    }

    /**
     * Add a list of reason codes for a given policy type.
     *
     * @remarks
     * Add a list of reason codes for a given policy type.<br /><b>Supported user types:</b> Service.
     */
    async postTimeoffPolicyTypesPolicyTypeReasonCodes(
        input: operations.PostTimeoffPolicyTypesPolicyTypeReasonCodesRequest,
        options?: RequestOptions
    ): Promise<operations.PostTimeoffPolicyTypesPolicyTypeReasonCodesResponse> {
        const headers$ = new Headers();
        headers$.set("user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "*/*");

        const payload$ = schemas$.parse(
            input,
            (value$) =>
                operations.PostTimeoffPolicyTypesPolicyTypeReasonCodesRequest$.outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$.ReasonCodesNames, { explode: true });

        const pathParams$ = {
            policyType: enc$.encodeSimple("policyType", payload$.policyType, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/timeoff/policy-types/{policyType}/reason-codes")(
            pathParams$
        );

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "post_/timeoff/policy-types/{policyType}/reason-codes",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: [] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchStatusCode(response, [200, 404])) {
            // fallthrough
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return schemas$.parse(
            undefined,
            () =>
                operations.PostTimeoffPolicyTypesPolicyTypeReasonCodesResponse$.inboundSchema.parse(
                    responseFields$
                ),
            "Response validation failed"
        );
    }
}
